// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bgs/low/pb/client/club_enum.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bgs_2flow_2fpb_2fclient_2fclub_5fenum_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bgs_2flow_2fpb_2fclient_2fclub_5fenum_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bgs_2flow_2fpb_2fclient_2fclub_5fenum_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bgs_2flow_2fpb_2fclient_2fclub_5fenum_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bgs_2flow_2fpb_2fclient_2fclub_5fenum_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace bgs {
namespace protocol {
namespace club {
namespace v1 {

enum PrivacyLevel : int {
  PRIVACY_LEVEL_CLOSED = 0,
  PRIVACY_LEVEL_OPEN_INVITATION = 1,
  PRIVACY_LEVEL_OPEN_TICKET = 2,
  PRIVACY_LEVEL_OPEN = 3
};
bool PrivacyLevel_IsValid(int value);
constexpr PrivacyLevel PrivacyLevel_MIN = PRIVACY_LEVEL_CLOSED;
constexpr PrivacyLevel PrivacyLevel_MAX = PRIVACY_LEVEL_OPEN;
constexpr int PrivacyLevel_ARRAYSIZE = PrivacyLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrivacyLevel_descriptor();
template<typename T>
inline const std::string& PrivacyLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrivacyLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrivacyLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrivacyLevel_descriptor(), enum_t_value);
}
inline bool PrivacyLevel_Parse(
    const std::string& name, PrivacyLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrivacyLevel>(
    PrivacyLevel_descriptor(), name, value);
}
enum VisibilityLevel : int {
  VISIBILITY_LEVEL_PRIVATE = 0,
  VISIBILITY_LEVEL_PUBLIC = 1
};
bool VisibilityLevel_IsValid(int value);
constexpr VisibilityLevel VisibilityLevel_MIN = VISIBILITY_LEVEL_PRIVATE;
constexpr VisibilityLevel VisibilityLevel_MAX = VISIBILITY_LEVEL_PUBLIC;
constexpr int VisibilityLevel_ARRAYSIZE = VisibilityLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VisibilityLevel_descriptor();
template<typename T>
inline const std::string& VisibilityLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VisibilityLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VisibilityLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VisibilityLevel_descriptor(), enum_t_value);
}
inline bool VisibilityLevel_Parse(
    const std::string& name, VisibilityLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VisibilityLevel>(
    VisibilityLevel_descriptor(), name, value);
}
enum ClubRemovedReason : int {
  CLUB_REMOVED_REASON_NONE = 0,
  CLUB_REMOVED_REASON_MEMBER_LEFT = 1,
  CLUB_REMOVED_REASON_MEMBER_KICKED = 2,
  CLUB_REMOVED_REASON_MEMBER_BANNED = 3,
  CLUB_REMOVED_REASON_MEMBER_REMOVED_BY_SERVICE = 4,
  CLUB_REMOVED_REASON_DESTROYED_BY_MEMBER = 5,
  CLUB_REMOVED_REASON_DESTROYED_BY_SERVICE = 6
};
bool ClubRemovedReason_IsValid(int value);
constexpr ClubRemovedReason ClubRemovedReason_MIN = CLUB_REMOVED_REASON_NONE;
constexpr ClubRemovedReason ClubRemovedReason_MAX = CLUB_REMOVED_REASON_DESTROYED_BY_SERVICE;
constexpr int ClubRemovedReason_ARRAYSIZE = ClubRemovedReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClubRemovedReason_descriptor();
template<typename T>
inline const std::string& ClubRemovedReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClubRemovedReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClubRemovedReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClubRemovedReason_descriptor(), enum_t_value);
}
inline bool ClubRemovedReason_Parse(
    const std::string& name, ClubRemovedReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClubRemovedReason>(
    ClubRemovedReason_descriptor(), name, value);
}
enum StreamVoiceLevel : int {
  VOICE_LEVEL_DISABLED = 0,
  VOICE_LEVEL_PUSH_TO_TALK = 1,
  VOICE_LEVEL_OPEN_MIC = 2
};
bool StreamVoiceLevel_IsValid(int value);
constexpr StreamVoiceLevel StreamVoiceLevel_MIN = VOICE_LEVEL_DISABLED;
constexpr StreamVoiceLevel StreamVoiceLevel_MAX = VOICE_LEVEL_OPEN_MIC;
constexpr int StreamVoiceLevel_ARRAYSIZE = StreamVoiceLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamVoiceLevel_descriptor();
template<typename T>
inline const std::string& StreamVoiceLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamVoiceLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamVoiceLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamVoiceLevel_descriptor(), enum_t_value);
}
inline bool StreamVoiceLevel_Parse(
    const std::string& name, StreamVoiceLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamVoiceLevel>(
    StreamVoiceLevel_descriptor(), name, value);
}
enum VoiceMicrophoneState : int {
  MICROPHONE_STATE_NORMAL = 0,
  MICROPHONE_STATE_SELF_MUTE = 1,
  MICROPHONE_STATE_SELF_DEAF = 2
};
bool VoiceMicrophoneState_IsValid(int value);
constexpr VoiceMicrophoneState VoiceMicrophoneState_MIN = MICROPHONE_STATE_NORMAL;
constexpr VoiceMicrophoneState VoiceMicrophoneState_MAX = MICROPHONE_STATE_SELF_DEAF;
constexpr int VoiceMicrophoneState_ARRAYSIZE = VoiceMicrophoneState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VoiceMicrophoneState_descriptor();
template<typename T>
inline const std::string& VoiceMicrophoneState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VoiceMicrophoneState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VoiceMicrophoneState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VoiceMicrophoneState_descriptor(), enum_t_value);
}
inline bool VoiceMicrophoneState_Parse(
    const std::string& name, VoiceMicrophoneState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VoiceMicrophoneState>(
    VoiceMicrophoneState_descriptor(), name, value);
}
enum PresenceLevel : int {
  PRESENCE_LEVEL_NONE = 0,
  PRESENCE_LEVEL_BASIC = 1,
  PRESENCE_LEVEL_RICH = 2
};
bool PresenceLevel_IsValid(int value);
constexpr PresenceLevel PresenceLevel_MIN = PRESENCE_LEVEL_NONE;
constexpr PresenceLevel PresenceLevel_MAX = PRESENCE_LEVEL_RICH;
constexpr int PresenceLevel_ARRAYSIZE = PresenceLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PresenceLevel_descriptor();
template<typename T>
inline const std::string& PresenceLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PresenceLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PresenceLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PresenceLevel_descriptor(), enum_t_value);
}
inline bool PresenceLevel_Parse(
    const std::string& name, PresenceLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PresenceLevel>(
    PresenceLevel_descriptor(), name, value);
}
enum WhisperLevel : int {
  WHISPER_LEVEL_OPEN = 0,
  WHISPER_LEVEL_RESTRICTED = 1
};
bool WhisperLevel_IsValid(int value);
constexpr WhisperLevel WhisperLevel_MIN = WHISPER_LEVEL_OPEN;
constexpr WhisperLevel WhisperLevel_MAX = WHISPER_LEVEL_RESTRICTED;
constexpr int WhisperLevel_ARRAYSIZE = WhisperLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WhisperLevel_descriptor();
template<typename T>
inline const std::string& WhisperLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WhisperLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WhisperLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WhisperLevel_descriptor(), enum_t_value);
}
inline bool WhisperLevel_Parse(
    const std::string& name, WhisperLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WhisperLevel>(
    WhisperLevel_descriptor(), name, value);
}
enum StreamNotificationFilter : int {
  STREAM_NOTIFICATION_FILTER_NONE = 0,
  STREAM_NOTIFICATION_FILTER_MENTION = 1,
  STREAM_NOTIFICATION_FILTER_ALL = 2
};
bool StreamNotificationFilter_IsValid(int value);
constexpr StreamNotificationFilter StreamNotificationFilter_MIN = STREAM_NOTIFICATION_FILTER_NONE;
constexpr StreamNotificationFilter StreamNotificationFilter_MAX = STREAM_NOTIFICATION_FILTER_ALL;
constexpr int StreamNotificationFilter_ARRAYSIZE = StreamNotificationFilter_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamNotificationFilter_descriptor();
template<typename T>
inline const std::string& StreamNotificationFilter_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamNotificationFilter>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamNotificationFilter_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamNotificationFilter_descriptor(), enum_t_value);
}
inline bool StreamNotificationFilter_Parse(
    const std::string& name, StreamNotificationFilter* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamNotificationFilter>(
    StreamNotificationFilter_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace club
}  // namespace protocol
}  // namespace bgs

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bgs::protocol::club::v1::PrivacyLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bgs::protocol::club::v1::PrivacyLevel>() {
  return ::bgs::protocol::club::v1::PrivacyLevel_descriptor();
}
template <> struct is_proto_enum< ::bgs::protocol::club::v1::VisibilityLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bgs::protocol::club::v1::VisibilityLevel>() {
  return ::bgs::protocol::club::v1::VisibilityLevel_descriptor();
}
template <> struct is_proto_enum< ::bgs::protocol::club::v1::ClubRemovedReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bgs::protocol::club::v1::ClubRemovedReason>() {
  return ::bgs::protocol::club::v1::ClubRemovedReason_descriptor();
}
template <> struct is_proto_enum< ::bgs::protocol::club::v1::StreamVoiceLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bgs::protocol::club::v1::StreamVoiceLevel>() {
  return ::bgs::protocol::club::v1::StreamVoiceLevel_descriptor();
}
template <> struct is_proto_enum< ::bgs::protocol::club::v1::VoiceMicrophoneState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bgs::protocol::club::v1::VoiceMicrophoneState>() {
  return ::bgs::protocol::club::v1::VoiceMicrophoneState_descriptor();
}
template <> struct is_proto_enum< ::bgs::protocol::club::v1::PresenceLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bgs::protocol::club::v1::PresenceLevel>() {
  return ::bgs::protocol::club::v1::PresenceLevel_descriptor();
}
template <> struct is_proto_enum< ::bgs::protocol::club::v1::WhisperLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bgs::protocol::club::v1::WhisperLevel>() {
  return ::bgs::protocol::club::v1::WhisperLevel_descriptor();
}
template <> struct is_proto_enum< ::bgs::protocol::club::v1::StreamNotificationFilter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bgs::protocol::club::v1::StreamNotificationFilter>() {
  return ::bgs::protocol::club::v1::StreamNotificationFilter_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bgs_2flow_2fpb_2fclient_2fclub_5fenum_2eproto
